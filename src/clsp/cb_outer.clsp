(mod
  (
    CB_MOD_HASH
    ACH_CLAW_HASH
    ACH_CLAIM_HASH
    P2_MERKLE_HASH
    TIMELOCK
    INNER_PH
    my_amount
    inner_puz
    inner_sol
  )

  ;; This puzzle wraps a standard inner puzzle and enforces that all CREATE_COIN conditions are
  ;; directed to a p2_merkle_tree puzzle which enables clawback or claiming once the timelock
  ;; has elapsed.

  (include condition_codes.clib)
  (include curry_and_treehash.clib)
  (include utility_macros.clib)
  (include merkle_utils.clib)
  (include *standard-cl-21*)

  (defun-inline opcode (condition) (f condition))
  (defun-inline puzhash (condition) (f (r condition)))
  (defun-inline amount (condition) (f (r (r condition))))

  ;; PUZZLES TO CURRY
  (defun-inline curry_outer (CB_MOD_HASH ACH_CLAW_HASH ACH_CLAIM_HASH P2_MERKLE_HASH TIMELOCK INNER_PH)
    (puzzle_hash_of_curried_function CB_MOD_HASH
      (sha256 1 INNER_PH)
      (sha256 1 TIMELOCK)
      (sha256 1 P2_MERKLE_HASH)
      (sha256 1 ACH_CLAIM_HASH)
      (sha256 1 ACH_CLAW_HASH)
      (sha256 1 CB_MOD_HASH)
    )
  )

  (defun-inline curry_claw (ACH_CLAW_HASH INNER_PH clawback_ph)
    (puzzle_hash_of_curried_function ACH_CLAW_HASH
      (sha256 1 INNER_PH)
      (sha256 1 clawback_ph)
    )
  )

  (defun-inline curry_claim (ACH_CLAIM_HASH TIMELOCK p2_ph)
    (puzzle_hash_of_curried_function ACH_CLAIM_HASH
      (sha256 1 p2_ph)
      (sha256 1 TIMELOCK)
    )
  )

  (defun-inline curry_merkle (P2_MERKLE_HASH MERKLE_ROOT)
    (puzzle_hash_of_curried_function P2_MERKLE_HASH
      (sha256 1 MERKLE_ROOT)
    )
  )

  ;; Get the merkle root from two inputs
  (defun-inline merkleize (left right)
    (simplify_merkle_proof left (list 0 (sha256 1 right)))
  )

  ;; FILTER CREATE_COIN CONDITIONS
  (defun handle_payment (CB_MOD_HASH ACH_CLAW_HASH ACH_CLAIM_HASH P2_MERKLE_HASH TIMELOCK INNER_PH conditions my_amount spend_amount)
    (if conditions
      (c
	(if (= (opcode (f conditions)) CREATE_COIN)
	  ;; if condition is CREATE_COIN morph the puzzle hash into the p2_merkle puzzle
	  (list CREATE_COIN
		(curry_merkle P2_MERKLE_HASH
		  (merkleize
		    (curry_claw ACH_CLAW_HASH INNER_PH (curry_outer CB_MOD_HASH ACH_CLAW_HASH ACH_CLAIM_HASH P2_MERKLE_HASH TIMELOCK INNER_PH))
		    (curry_claim ACH_CLAIM_HASH TIMELOCK (puzhash (f conditions))))
		)
		(amount (f conditions)))
	  ;; otherwise just return the condition
	  (f conditions)
	)
	;; recurse, updating the spend amount if we hit a create_coin condition
	(handle_payment CB_MOD_HASH ACH_CLAW_HASH ACH_CLAIM_HASH P2_MERKLE_HASH TIMELOCK INNER_PH (r conditions) my_amount (if (= (opcode (f conditions)) CREATE_COIN) (+ spend_amount (amount (f conditions))) spend_amount))
      )
      ;; finally add the change condition
      (assert (> spend_amount 0)
        (if (= spend_amount my_amount)
	  ()
	  (c (list CREATE_COIN (curry_outer CB_MOD_HASH ACH_CLAW_HASH ACH_CLAIM_HASH P2_MERKLE_HASH TIMELOCK INNER_PH) (- my_amount spend_amount)) ())
	)
      )
    )
  )

  ;; MAIN
  ;; check the inner puzzle is correct, assert my_amount and generate the p2_merkle coins
  (assert (= (sha256tree inner_puz) INNER_PH)
    (c
      (list ASSERT_MY_AMOUNT my_amount)
      (handle_payment CB_MOD_HASH ACH_CLAW_HASH ACH_CLAIM_HASH P2_MERKLE_HASH TIMELOCK INNER_PH (a inner_puz inner_sol) my_amount 0)
    )
  )

)
